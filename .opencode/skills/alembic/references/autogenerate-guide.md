# Autogenerate Guide

Covers what autogenerate can and cannot detect, type handling, custom rendering, post-write hooks, and CI integration.

## Table of Contents

- [What Autogenerate Detects](#what-autogenerate-detects)
- [What Autogenerate Does NOT Detect](#what-autogenerate-does-not-detect)
- [Handling Renames (Tables and Columns)](#handling-renames-tables-and-columns)
- [Type Comparison](#type-comparison)
- [Custom Type Rendering](#custom-type-rendering)
- [Post-Write Hooks](#post-write-hooks)
- [CI Integration with alembic check](#ci-integration-with-alembic-check)
- [Third-Party Autogenerate Extensions](#third-party-autogenerate-extensions)

---

## What Autogenerate Detects

Run with:

```bash
alembic revision --autogenerate -m "describe the change"
```

Autogenerate **reliably detects**:

| Change | Notes |
|--------|-------|
| Table additions | Creates `op.create_table(...)` |
| Table removals | Creates `op.drop_table(...)` |
| Column additions | Creates `op.add_column(...)` |
| Column removals | Creates `op.drop_column(...)` |
| Nullable status changes | Detects `nullable=True/False` changes |
| Named unique constraint changes | Requires named constraints (see naming convention) |
| Named index changes | Detects basic index add/drop |
| Named foreign key changes | Detects basic FK add/drop |

Autogenerate **optionally detects** (enabled by default since Alembic 1.12):

| Change | How to Control |
|--------|---------------|
| Column type changes | `compare_type=True` (default) / `compare_type=False` to disable |
| Server default changes | `compare_server_default=True` (off by default; can produce false positives) |

---

## What Autogenerate Does NOT Detect

These are **manual migration** scenarios:

| Scenario | What Autogenerate Generates Instead | Correct Action |
|----------|-------------------------------------|----------------|
| Table rename | `drop_table` + `create_table` | Use `op.rename_table(old, new)` |
| Column rename | `drop_column` + `add_column` | Use `op.alter_column(table, old, new_column_name=new)` |
| Anonymously named constraints | Nothing (invisible to diff) | Use `MetaData(naming_convention=...)` |
| PostgreSQL `ENUM` on non-native ENUM backends | Nothing | Handle with `column_reflect` event |
| Sequences | Nothing (not yet implemented) | Write manually |
| CHECK constraints (some backends) | Not fully supported | Write manually |

**The golden rule**: autogenerate produces *candidate* migrations. Always read and edit the generated script before running `alembic upgrade`.

---

## Handling Renames (Tables and Columns)

When a table or column is renamed in the model, autogenerate produces an add+drop pair. Edit the generated script to use the correct operation:

### Table rename

```python
# Replace autogenerated drop_table + create_table with:
def upgrade():
    op.rename_table('old_table_name', 'new_table_name')

def downgrade():
    op.rename_table('new_table_name', 'old_table_name')
```

### Column rename

```python
def upgrade():
    op.alter_column('account', 'username', new_column_name='login')

def downgrade():
    op.alter_column('account', 'login', new_column_name='username')
```

---

## Type Comparison

Autogenerate compares types in two steps:

1. **Outer type** — e.g., `VARCHAR` vs `TEXT`. Dialect synonyms are considered equivalent (e.g., `NUMERIC` = `DECIMAL` on all backends).
2. **Type arguments** — lengths, precision, enum members. Compared only when **both** columns specify arguments; if one is a default, no change is flagged to avoid false positives.

### Custom type comparison

```python
def my_compare_type(context, inspected_column, metadata_column,
                    inspected_type, metadata_type):
    """
    Return False  → types match, no migration needed
    Return True   → types differ, generate alter_column
    Return None   → use Alembic's default comparison
    """
    if isinstance(metadata_type, MySpecialType):
        return str(inspected_type) != repr(metadata_type)
    return None

context.configure(
    connection=connection,
    target_metadata=target_metadata,
    compare_type=my_compare_type,
)
```

---

## Custom Type Rendering

Autogenerate renders types using their `__repr__()`. For custom types, ensure `__repr__` produces a valid constructor call.

### user_module_prefix

Avoid verbose `myapp.models.utils.types.MyCustomType()` prefixes by centralizing custom types:

```python
# myapp/migration_types.py
from myapp.models.utils.types import MyCustomType, AnotherType
```

Add the import to `script.py.mako`:

```python
from alembic import op
import sqlalchemy as sa
import myapp.migration_types
${imports if imports else ""}
```

Set the prefix in `env.py`:

```python
context.configure(
    connection=connection,
    target_metadata=target_metadata,
    user_module_prefix="myapp.migration_types.",
)
```

Generated migrations will now render `myapp.migration_types.MyCustomType()`. When the type moves within the application, only `migration_types.py` needs updating.

### render_item hook

Full control over how individual items are rendered:

```python
def render_item(type_, obj, autogen_context):
    if type_ == 'type' and isinstance(obj, MySpecialType):
        autogen_context.imports.add("from mypackage import special_types")
        return "special_types.%r" % obj
    return False  # use default rendering

context.configure(
    connection=connection,
    target_metadata=target_metadata,
    render_item=render_item,
)
```

---

## Post-Write Hooks

Post-write hooks run against each newly generated revision file immediately after creation.

### ruff (recommended for modern projects)

`alembic.ini`:

```ini
[post_write_hooks]
hooks = ruff

ruff.type = exec
ruff.executable = ruff
ruff.options = check --fix REVISION_SCRIPT_FILENAME
```

`pyproject.toml` equivalent:

```toml
[[tool.alembic.post_write_hooks]]
name = "ruff"
type = "exec"
executable = "ruff"
options = "check --fix REVISION_SCRIPT_FILENAME"
```

### black + ruff (sequential hooks)

```ini
[post_write_hooks]
hooks = black, ruff

black.type = console_scripts
black.entrypoint = black
black.options = -l 88 REVISION_SCRIPT_FILENAME

ruff.type = exec
ruff.executable = ruff
ruff.options = check --fix REVISION_SCRIPT_FILENAME
```

Hooks run in the listed order. The revision file path is substituted for `REVISION_SCRIPT_FILENAME`.

### Custom Python hook

Register a hook function in `env.py` and set `revision_environment = true` in `alembic.ini` to ensure `env.py` loads during the `revision` command:

```python
# env.py
from alembic.script import write_hooks

@write_hooks.register("add_noqa")
def add_noqa_to_generated(filename, options):
    """Append # noqa: E501 to long lines in generated scripts."""
    with open(filename) as f:
        lines = f.readlines()
    with open(filename, "w") as f:
        for line in lines:
            if len(line.rstrip()) > 88:
                line = line.rstrip() + "  # noqa: E501\n"
            f.write(line)
```

`alembic.ini`:

```ini
[alembic]
revision_environment = true

[post_write_hooks]
hooks = add_noqa
add_noqa.type = add_noqa
```

---

## CI Integration with alembic check

`alembic check` performs the full autogenerate comparison but generates no files. It exits with a non-zero code if new operations would be emitted.

```bash
alembic check
# Success: "No new upgrade operations detected."
# Failure: "FAILED: New upgrade operations detected: [...]"
```

### GitHub Actions example

```yaml
- name: Check for missing migrations
  run: |
    alembic check
  env:
    DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}
```

### Limitations of alembic check

`alembic check` uses the same detection logic as `alembic revision --autogenerate`. This means:
- It respects `compare_type`, `compare_server_default`, `include_name`, `include_object`.
- It inherits the same blind spots (renames, anonymous constraints, sequences).
- A passing `alembic check` means autogenerate would produce an empty migration — not that the schema is necessarily correct.

---

## Third-Party Autogenerate Extensions

| Library | What it adds |
|---------|-------------|
| [alembic-utils](https://github.com/olirice/alembic_utils) | PostgreSQL functions, views, triggers, policies |
| [alembic-postgresql-enum](https://pypi.org/project/alembic-postgresql-enum) | PostgreSQL `ENUM` create/alter/drop detection |

Install these alongside `alembic` and follow each library's `env.py` integration instructions.
